<!DOCTYPE html>
<html lang="en">
  <head>
    <script type="text/javascript" src="./src/script.js"></script>
    <script type="text/javascript" src="./common/OBJParser.js"></script>

    <!-- WGSL code goes here -->
    <script id="wgsl" type="x-shader">

         @group(0) @binding(0) var<uniform> funiforms : FUniforms;

        struct HitInfo {
          hasHit: bool,
          normal: vec3<f32>,
          point: vec3<f32>,
          distance: f32,
          depth: i32,
          color: vec4<f32>,
          IOR: f32,
          material: u32
        }

        struct Ray {
          origin: vec3f,
          direction: vec3f,
          tmin: f32,
          tmax: f32,
        };

        struct FUniforms {
          scrollValue: f32,
          theta: f32
        };

        struct VSOut {
          @builtin(position) position: vec4f,
          @location(0) coords : vec2f,
        };

        const lookAtPoint:vec3<f32> = vec3f(0.0, 0.5, 0.0);
        const eyePoint:vec3<f32> = vec3f(2.0,1.5,2.0);
        const upVector:vec3<f32> = vec3f(0.0,1.0,0.0);
        const lightPos = vec3f(1.0,1.0,1.0);

        const DEBUG_RED =  vec4f(1.0,0.0,0.0,1.0);
        const DEBUG_WHITE =  vec4f(0.6,0.6,0.6,1.0);

        @vertex
        fn main_vs(@builtin(vertex_index) VertexIndex : u32) -> VSOut
        {
          const pos = array<vec2f, 4>(vec2f(-1.0, 1.0), vec2f(-1.0, -1.0), vec2f(1.0, 1.0), vec2f(1.0, -1.0));
          var vsOut: VSOut;
          vsOut.position = vec4f(pos[VertexIndex], 0.0, 1.0);
          vsOut.coords = pos[VertexIndex];
          return vsOut;
        }

        fn intersectRayWithPlane(ray:ptr<function, Ray>, hitResult:ptr<function, HitInfo>, plane: RoundPlane) -> bool {      
          var pointOnPlane = plane.point;
          var planeNormal = plane.normal;
          var radius = plane.radius;
      
          var rayDirection = (*ray).direction;
          var rayOrigin = (*ray).origin;
      
          var denominator = dot(rayDirection, planeNormal);

          var distanceToHit = dot(pointOnPlane - rayOrigin, planeNormal) / denominator;
      
          if (distanceToHit < (*ray).tmin || distanceToHit > (*ray).tmax) {
            return false;
          }
      
          // Check if the ray and plane are parallel (denominator is close to 0)
          if (abs(denominator) < 1e-6) {
            return false;
          }
      
          // Calculate the intersection point
          var intersectionPoint = rayOrigin + distanceToHit * rayDirection;
      
          if (length(intersectionPoint - pointOnPlane) > radius || length(intersectionPoint - pointOnPlane) > radius) {
            return false;
          }
          
          (*ray).tmax = distanceToHit;
          (*hitResult).point = intersectionPoint;
          (*hitResult).normal = plane.normal;
          (*hitResult).hasHit = true;
          return true;
        }

        fn cylinderIntersect(ray:ptr<function, Ray>, hitResult:ptr<function, HitInfo>, cylinder: Cylinder) -> HitInfo {

          var cylinderStartPoint = cylinder.start;
          var cylinderEndPoint = cylinder.end;
          var cylinderRadius = cylinder.radius;

          var plane1 = RoundPlane(cylinder.start, -normalize(cylinder.end-cylinder.start), cylinder.radius);
          var plane2 = RoundPlane(cylinder.end, -normalize(cylinder.start-cylinder.end), cylinder.radius);

          var rayDirection = (*ray).direction;
          var rayOrigin = (*ray).origin;

          var cylinderAxis = cylinderEndPoint - cylinderStartPoint;
          var oc = rayOrigin - cylinderStartPoint;

          var axisDotAxis = dot(cylinderAxis, cylinderAxis);
          var axisDotRayDirection = dot(cylinderAxis, rayDirection);
          var axisDotOC = dot(cylinderAxis, oc);

          var k2 = axisDotAxis - axisDotRayDirection * axisDotRayDirection;
          var k1 = axisDotAxis * dot(oc, rayDirection) - axisDotOC * axisDotRayDirection;
          var k0 = axisDotAxis * dot(oc, oc) - axisDotOC * axisDotOC - cylinderRadius * cylinderRadius * axisDotAxis;

          var discriminant = k1 * k1 - k2 * k0;

          intersectRayWithPlane(ray, hitResult, plane1);
          intersectRayWithPlane(ray, hitResult, plane2);

          if (discriminant < 0.0) {
            return (*hitResult);
          }

          /////////////////////////////////////////////////////////////
          // Check if the intersection point is on the cylinder body //
          /////////////////////////////////////////////////////////////

          let sqrtDiscriminant = sqrt(discriminant);
          var t = (-k1 - sqrtDiscriminant) / k2;
          var y = axisDotOC + t * axisDotRayDirection;

          if (t < (*ray).tmin || t > (*ray).tmax) {
            return (*hitResult);
          }

          if (y > 0.0 && y < axisDotAxis) {
            let intersectionPoint = rayOrigin + t * rayDirection;
            let normal = (intersectionPoint - cylinderStartPoint - cylinderAxis * (y / axisDotAxis)) / cylinderRadius;
            (*ray).tmax = t;
            (*hitResult).point = intersectionPoint;
            (*hitResult).normal = normal;
            (*hitResult).hasHit = true;
            return (*hitResult);
          }

          /////////////////////////////////////////////////////////////
          // Check if the intersection point is on the cylinder caps //
          /////////////////////////////////////////////////////////////

 
          return (*hitResult);
        }

        struct Cylinder {
          radius: f32,
          height: f32,
          start: vec3f, 
          end: vec3f, 
        }

        struct RoundPlane {
          point: vec3f, 
          normal: vec3f, 
          radius: f32
        }

        fn rotateZ3D(theta: f32) -> mat3x3<f32>{
          var c = cos(theta);
          var s = sin(theta);
      
          return mat3x3(
            vec3f(c, -s, 0.0),
            vec3f(s, c, 0.0),
            vec3f(0.0, 0.0, 1.0)
          );
        }

        fn shade(hitResult: HitInfo) -> vec4f {
          var ambient = vec3f(0.1);
          var lightDir = normalize( lightPos - hitResult.point );
          var diffuse = ( dot( hitResult.normal, lightDir ) );
          diffuse = clamp( diffuse, 0, 1);
          var v = normalize(vec3f(funiforms.scrollValue, funiforms.scrollValue, 0.0) - hitResult.point);
          var shinnyfactor = 40.0;
          var h = (lightDir+v)*0.5;
          var hdotn = dot(h,hitResult.normal);
          var specular = pow(hdotn, shinnyfactor);
              
          var fragColor = ambient +
                          vec3f(0.9,0.7,0.1) * diffuse +
                          vec3f(1.0,0.9,0.9) * specular;

          return vec4f(fragColor, 1.0);
        }

        fn sceneIntersect(ray:ptr<function, Ray>, hitResult:ptr<function, HitInfo>) -> HitInfo
        {
          var rotMatrix = rotateZ3D(funiforms.theta);
          var cylinder = Cylinder(1.0, 0.5, rotMatrix*vec3f(0.0,-0.1,0.0), rotMatrix*vec3f(0.0,0.1,0.0));
          cylinderIntersect(ray, hitResult, cylinder);
          (*hitResult).point = (*hitResult).point;
          return (*hitResult);
        }

        fn getRay(uv: vec2f) -> Ray 
        {
          var adjusted_eye = vec3f(funiforms.scrollValue, funiforms.scrollValue, 0.0);
          var v =  normalize(lookAtPoint-adjusted_eye);
          var b1 = normalize(cross(v, upVector));
          var b2 = (cross(b1, v));
          var q = normalize(uv.x * b1 + uv.y * b2 + v);
          var ray: Ray;
          ray.origin = adjusted_eye;
          ray.direction = q;
          ray.tmin = 0.001;
          ray.tmax = 100;
          return ray;
        }

        fn getBackgroundColor(uv: vec2f) -> vec4f 
        {
          var dayBlue = vec4f(0.529, 0.808, 0.922, 1.0); 
          var duskPurple = vec4f(0.5, 0.0, 0.5, 1.0);     
          var mixFactor = (uv.y) * 1.5;           
          var skyColor = mix(dayBlue, duskPurple, mixFactor); 
          return skyColor;
        }

         @fragment
         fn main_fs(@location(0) coords: vec2f) -> @location(0) vec4f {

          var uv = vec2f(coords.x*0.5, coords.y*0.5);
          
          var backgroundColor = getBackgroundColor(uv);

          var ray = getRay(uv);
          var hitResult: HitInfo;
          hitResult.hasHit = false;

          var fragColor = vec4f(0.0);
          sceneIntersect(&ray, &hitResult);

          if( hitResult.hasHit ) { 
            fragColor = shade(hitResult);
          }

          else { fragColor = backgroundColor; }

          return vec4<f32>(fragColor.rgb, 1.0);
        }

    </script
    <meta charset="UTF-8" />

    <title>
      Rendering Realistic Gemstones with Physically Based Rendering Techniques
    </title>
    <link rel="stylesheet" href="styles.css" />
  </head>
  <body>
    <h3>02562 Rendering - Jessie Lonsdale S230002</h3>

    <h1>
      ⚜️ Rendering Many Golden Doubloons ⚜️
    </h1>

    <div id="canvas-container">
      <canvas id="c" width="600" height="600"></canvas>
      <div id="gem-info">
        <div class="toggle-container">
          <label class="toggle-label">Low Performance Mode:</label>
          <label class="toggle-switch">
            <input type="checkbox" id="performance-toggle" checked />
            <span class="toggle-slider"></span>
          </label>
        </div>

        </div>
      </div>
    </div>
  </body>
</html>
